[
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "Function Reference",
    "section": "",
    "text": "This page will list exported functions from the GeoLink package."
  },
  {
    "objectID": "articles/functions_s3.html",
    "href": "articles/functions_s3.html",
    "title": "Functions for S3 buckets",
    "section": "",
    "text": "read_from_s3() loads spatial data directly from an S3 bucket and returns it as either an sf object (for vector data) or a SpatRaster (for raster data). The function detects the file format automatically from the file extension unless you specify it manually.\nThe function supports: - GeoParquet (.parquet) ‚Äî read directly via Arrow + sfarrow\n- GeoPackage (.gpkg) ‚Äî downloaded temporarily, then read with sf\n- GeoTIFF (.tif) ‚Äî downloaded temporarily, then read with terra\nInternally, the function handles all S3 communication, temporary files, and format-specific reading. This means you can load S3-based spatial data with a single line of code, without worrying about URLs, credentials, or file formats.\nThis function is useful when: - you store datasets in buckets instead of local directories\n- you work with mixed formats (e.g., raster + vector)\n- you need a consistent interface for reading data from internal S3\n- you prefer lightweight, single-file spatial formats such as Parquet, GPKG, and GeoTIFF"
  },
  {
    "objectID": "articles/functions_s3.html#read_from_s3",
    "href": "articles/functions_s3.html#read_from_s3",
    "title": "Functions for S3 buckets",
    "section": "",
    "text": "read_from_s3() loads spatial data directly from an S3 bucket and returns it as either an sf object (for vector data) or a SpatRaster (for raster data). The function detects the file format automatically from the file extension unless you specify it manually.\nThe function supports: - GeoParquet (.parquet) ‚Äî read directly via Arrow + sfarrow\n- GeoPackage (.gpkg) ‚Äî downloaded temporarily, then read with sf\n- GeoTIFF (.tif) ‚Äî downloaded temporarily, then read with terra\nInternally, the function handles all S3 communication, temporary files, and format-specific reading. This means you can load S3-based spatial data with a single line of code, without worrying about URLs, credentials, or file formats.\nThis function is useful when: - you store datasets in buckets instead of local directories\n- you work with mixed formats (e.g., raster + vector)\n- you need a consistent interface for reading data from internal S3\n- you prefer lightweight, single-file spatial formats such as Parquet, GPKG, and GeoTIFF"
  },
  {
    "objectID": "articles/functions_s3.html#write_to_s3",
    "href": "articles/functions_s3.html#write_to_s3",
    "title": "Functions for S3 buckets",
    "section": "write_to_s3()",
    "text": "write_to_s3()\nwrite_to_s3() uploads spatial data (vector or raster) to an S3 bucket.\nIt handles both the conversion to a single-file format and the upload to the bucket.\nSupported output formats include: - .gpkg (GeoPackage) ‚Äî supports multiple internal layers\n- .parquet (GeoParquet) ‚Äî lightweight and highly portable\n- .tif (GeoTIFF) ‚Äî for raster data\nNot supported: - shapefiles (.shp), because they require multiple companion files\n- Esri File Geodatabases (.gdb), because they are folder-based formats\nVectors (sf) are written using either st_write() or sfarrow::st_write_parquet(), and rasters (SpatRaster) are written with terra::writeRaster().\nThe function then uploads the resulting file to S3 using aws.s3::put_object().\nThis function is especially helpful for: - storing analysis-ready datasets in shared internal buckets\n- pipeline automation where outputs need to be uploaded as part of processing\n- converting spatial formats to stable, single-file S3-friendly versions\n- ensuring that exported data is consistently written with a reproducible workflow"
  },
  {
    "objectID": "articles/functions_s3.html#list_from_s3",
    "href": "articles/functions_s3.html#list_from_s3",
    "title": "Functions for S3 buckets",
    "section": "list_from_s3()",
    "text": "list_from_s3()\nlist_from_s3() lists the files stored in an S3 bucket, with optional filtering by prefix (a folder-like path) or by file extension.\nIt returns either: - a vector of keys (file paths), or\n- a data frame with metadata (size, last modified time)\nYou can use prefix to list only the contents of a specific subfolder, such as:\nprefix = \"grunnkart/\"\nYou can also limit the results to a specific file type, such as:\nfile_type = \".parquet\"\nThis function is a practical way to: - explore datasets stored in S3 buckets\n- script reproducible workflows that need to know which files exist\n- automatically select resources or versions based on bucket contents\n- check for expected input/output files in bucket-based pipelines\nTogether, these three functions provide a streamlined way to browse, read, and write spatial datasets stored inside NINA‚Äôs internal S3 infrastructure."
  },
  {
    "objectID": "articles/functions.html",
    "href": "articles/functions.html",
    "title": "Functions",
    "section": "",
    "text": "Overview of functions\nAs part of the GeoLink project, we have created a series of R functions to make it easier to work with spatial data in your R workflows.\nFunctions are designed for each major platform that hosts spatial data at NINA. Those platforms are the R:\\GeoSpatialData folder, GRASS, the PostGIS database, and S3 buckets.\nNote that some platforms will have functions for both reading and writing data on the platform. Others are read only.\nIt is not possible to write data onto the R:\\GeoSpatialData folder or the PostGIS database. You can write data to a GRASS mapset or to an S3 bucket.\nIndividual pages will describe the functions in more detail. Use the navigation bar to select the platform of interest."
  },
  {
    "objectID": "articles/geodata_sources.html",
    "href": "articles/geodata_sources.html",
    "title": "Geospatial Data Sources",
    "section": "",
    "text": "This page provides an overview of the main geospatial data repositories used in the GeoLink project, with links to detailed pages for each source."
  },
  {
    "objectID": "articles/geodata_sources.html#overview-of-data-sources",
    "href": "articles/geodata_sources.html#overview-of-data-sources",
    "title": "Geospatial Data Sources",
    "section": "üóÇÔ∏è Overview of Data Sources",
    "text": "üóÇÔ∏è Overview of Data Sources\n\n\n\nSource\nDescription\nLink to details\n\n\n\n\nGeoSpatialData\nCentral folder on the R drive with raster, vector, and grid data\nGeoSpatialData on R Drive\n\n\nGRASS GIS\nGRASS-based spatial database used for modeling and processing workflows\nGRASS GIS Environment\n\n\nGIS Database\nPostgreSQL/PostGIS database containing processed data ready for modeling\nPostgreSQL GIS Database"
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "MIT License",
    "section": "",
    "text": "MIT License\nCopyright (c) 2025 Jenny Hansen\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ‚ÄúSoftware‚Äù), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "GeoLink.html",
    "href": "GeoLink.html",
    "title": "Welcome to GeoLink",
    "section": "",
    "text": "This is the landing page for the GeoLink package website."
  },
  {
    "objectID": "articles/data_geospatialdata.html",
    "href": "articles/data_geospatialdata.html",
    "title": "GeoSpatialData folder on the R Drive",
    "section": "",
    "text": "üó∫Ô∏è GeoSpatialData on the R Drive\nThe GeoSpatialData folder on the R: drive is a centralized collection of raster, vector, and gridded spatial datasets used in many of NINA‚Äôs GIS workflows. It includes base layers such as:\n\nLand cover and vegetation maps\nElevation models (DEM)\nHydrology and slope layers\nMunicipality boundaries and grids (e.g., SSB grids)\nGridded climate data\n\nThere is a data inventory Excel spreadsheet at R:\\GeoSpatialData\\Data\\_Inventory.xlsx where you can find the most current overview of the data available on the R drive. Data is generally grouped into broad categories such as AdministrativeUnits, Elevation, Hydrography, Landcover, StatisticalUnits, Topography, etc.\nWithin each subfolder of a category, you can expect to see five subfolders:\n\nConverted\nOriginal\nProcessed\nScripts\nShared\n\nOriginal (raw) data is in the Original subfolder and is what most people generally work with. The Converted subfolder is usually empty, but some may contain data, e.g.¬†Norway_AdministrativeUnits in AdministrativeUnits. Many of the datasets will have files in the Processed folder. This may include data converted from one type to another, data clipped or subset to a specific region, changes in projections (CRS), etc. The Scripts subfolder will contain the relevant scripts used to process or convert data, e.g.¬†from SOSI to shp. The purpose of the Shared subfolder is unknown.\nGeoLink contains a pair of helper functions to find and import data from the GeoSpatialData folder on the R drive. Note that these only work when working from the [NINA RStudio server] (https://rstudio.nina.no) or the GIS server (accessed through Omnissa Horizon Client.\n\n\nGeoLink functions for R:"
  },
  {
    "objectID": "articles/data_grass.html",
    "href": "articles/data_grass.html",
    "title": "GRASS GIS",
    "section": "",
    "text": "GRASS GIS (Geographic Resources Analysis Support System) is an open-source geospatial analysis platform built around a highly structured data management model. Instead of working with standalone files like GeoTIFFs or shapefiles, GRASS organizes all data inside a GIS database‚Äîa directory structure composed of locations and mapsets. Each location has a defined coordinate reference system (CRS), and every raster or vector layer stored inside it must conform to that CRS.\nAt NINA, locations are typically named after the CRS they use‚Äîfor example, ETRS_32N or ETRS_33N. Within each location, mapsets follow a naming convention that indicates their purpose or theme:\n\ng_ mapsets contain shared datasets organized by theme (e.g., g_AdministrativeUnits, g_Elevation_Fenoscandia, g_Meteorology_Fenoscandia).\ngt_ mapsets contain meteorological datasets, primarily seNorge climate grids (e.g., gt_Meteorology_Norway_seNorge_Precipitation_normals, gt_Meteorology_Norway_seNorge_SnowDepth_days).\np_ mapsets are project-specific workspaces for datasets related to a particular project (e.g., p_NiN_landskap, p_redlist_hotspots).\nu_ mapsets are user-specific workspaces, named using the format u_user.name.\n\nUnlike typical desktop GIS workflows‚Äîwhere datasets are loaded directly from individual files‚ÄîGRASS works with its own internal copies of data. When you import a GeoTIFF or shapefile, GRASS converts it into an optimized GRASS raster or vector format. Analyses then operate on these internal datasets using modules that rely on GRASS‚Äôs computational region, resolution, and masking system."
  },
  {
    "objectID": "articles/data_grass.html#overview",
    "href": "articles/data_grass.html#overview",
    "title": "GRASS GIS",
    "section": "",
    "text": "GRASS GIS (Geographic Resources Analysis Support System) is an open-source geospatial analysis platform built around a highly structured data management model. Instead of working with standalone files like GeoTIFFs or shapefiles, GRASS organizes all data inside a GIS database‚Äîa directory structure composed of locations and mapsets. Each location has a defined coordinate reference system (CRS), and every raster or vector layer stored inside it must conform to that CRS.\nAt NINA, locations are typically named after the CRS they use‚Äîfor example, ETRS_32N or ETRS_33N. Within each location, mapsets follow a naming convention that indicates their purpose or theme:\n\ng_ mapsets contain shared datasets organized by theme (e.g., g_AdministrativeUnits, g_Elevation_Fenoscandia, g_Meteorology_Fenoscandia).\ngt_ mapsets contain meteorological datasets, primarily seNorge climate grids (e.g., gt_Meteorology_Norway_seNorge_Precipitation_normals, gt_Meteorology_Norway_seNorge_SnowDepth_days).\np_ mapsets are project-specific workspaces for datasets related to a particular project (e.g., p_NiN_landskap, p_redlist_hotspots).\nu_ mapsets are user-specific workspaces, named using the format u_user.name.\n\nUnlike typical desktop GIS workflows‚Äîwhere datasets are loaded directly from individual files‚ÄîGRASS works with its own internal copies of data. When you import a GeoTIFF or shapefile, GRASS converts it into an optimized GRASS raster or vector format. Analyses then operate on these internal datasets using modules that rely on GRASS‚Äôs computational region, resolution, and masking system."
  },
  {
    "objectID": "articles/data_grass.html#accessing-grass-data-at-nina",
    "href": "articles/data_grass.html#accessing-grass-data-at-nina",
    "title": "GRASS GIS",
    "section": "Accessing GRASS data at NINA",
    "text": "Accessing GRASS data at NINA\nNINA hosts a large collection of spatial datasets in GRASS, which can be accessed from R. However, you can only work with GRASS data when using one of NINA‚Äôs Linux servers‚Äîeither the GIS server (via the Omnissa client) or one of the RStudio servers:\n\nhttps://rstudio.nina.no/\nhttps://rstudio-geo.nina.no/\n\nTo connect from R, use the helper function provided in the NinaR package:\ndevtools::install_github(\"NINAnor/NinaR\")\nlibrary(rgrass)\nlibrary(NinaR)\n\nNinaR::grassConnect()\nCalling grassConnect() without arguments automatically creates a user mapset inside the default location (ETRS_33N), named u_user.name, where user.name is your NINA login (typically first.last).\nTo connect to a different location:\nNinaR::grassConnect(location = \"ETRS_35N\")\nTo connect directly to a specific mapset:\nNinaR::grassConnect(mapset = \"gt_Meteorology_Norway_seNorge_v2309_SnowDepth_month\")\nYou can list available datasets within the active mapset with:\nexecGRASS(\"g.list\", parameters = list(type = \"vector\"))\nexecGRASS(\"g.list\", parameters = list(type = \"raster\"))"
  },
  {
    "objectID": "articles/data_grass.html#understanding-region-resolution-and-masks",
    "href": "articles/data_grass.html#understanding-region-resolution-and-masks",
    "title": "GRASS GIS",
    "section": "Understanding region, resolution, and masks",
    "text": "Understanding region, resolution, and masks\nIn GRASS GIS, the computational region defines the spatial extent (bounding box) and resolution at which all raster operations are performed. This region is independent of any individual dataset; instead, it is a user-controlled setting that governs how analyses align input layers and produce output. GRASS automatically resamples or aligns inputs to this region, ensuring consistent and reproducible results.\nYou can set the region using an existing raster or vector:\nexecGRASS(\"g.region\", parameters = list(raster = \"my_raster\", res = 100))\nexecGRASS(\"g.region\", parameters = list(vector = \"my_vector\"))\nOr you can define the region manually. For example, this bounding box covers part of the Oslofjord area in EPSG:25833 with 10 m resolution:\nexecGRASS(\n  \"g.region\",\n  parameters = list(n = 6640000, s = 6575000, e = 610000, w = 520000, res = 10)\n)\nAny raster operation you perform will be constrained to this region.\n\nMasks\nGRASS also uses an optional mask, which restricts raster calculations to a defined area. Any cells outside the mask become NULL, even if underlying data exists there. This allows you to focus analyses on specific boundaries or study areas without physically clipping datasets.\nCreate a mask from a raster:\nexecGRASS(\"r.mask\", parameters = list(raster = \"mask_raster\"))\nOr from a vector:\nexecGRASS(\"r.mask\", parameters = list(vector = \"mask_vector\"))\nRemove the mask:\nexecGRASS(\"r.mask\", flags = \"r\")"
  },
  {
    "objectID": "articles/data_grass.html#checking-the-active-region-resolution-and-mask",
    "href": "articles/data_grass.html#checking-the-active-region-resolution-and-mask",
    "title": "GRASS GIS",
    "section": "Checking the active region, resolution, and mask",
    "text": "Checking the active region, resolution, and mask\nBecause region and mask settings persist until changed, it‚Äôs important to check them regularly.\n\nPrint region (human-readable)\nexecGRASS(\"g.region\", flags = \"p\")\nThis prints:\n\nnorth/south/east/west bounds\n\ncurrent resolution\n\nrows/cols\n\ndata type\n\nprojection info\n\n\n\nCheck whether a mask is active\nexecGRASS(\"g.list\", parameters = list(type = \"raster\", pattern = \"MASK\"), intern = TRUE)\nIf a mask is active, you will see \"MASK\" in the output.\n\nNavigate to Functions ‚Üí GRASS functions to see the GRASS-related helper functions available in GeoLink. A full vignette (‚ÄúGRASS vignette‚Äù) is also available under the vignette options and demonstrates how to work with GRASS datasets stored at NINA."
  },
  {
    "objectID": "articles/index.html",
    "href": "articles/index.html",
    "title": "Articles",
    "section": "",
    "text": "This page will contain longer documentation, vignettes, or use-case tutorials."
  },
  {
    "objectID": "articles/functions_geospatialdata.html#list_from_rgsd",
    "href": "articles/functions_geospatialdata.html#list_from_rgsd",
    "title": "Functions for data on R:",
    "section": "list_from_rgsd()",
    "text": "list_from_rgsd()\nlist_from_rgsd() provides a simple way to explore the contents of NINA‚Äôs shared GeoSpatialData directory, located at /data/R/GeoSpatialData on NINA‚Äôs servers. The directory contains a large number of spatial datasets organized into thematic folders, and this function makes it easier to inspect what is available without opening the directory manually.\nYou can supply either: - a full absolute path, such as /data/R/GeoSpatialData/Topography/Norway_N50, or\n- a relative subpath, such as \"Topography\" or \"Hydrography/Norway_Catchments/Original\".\nThe function then returns a list of everything inside that folder. You can control what gets returned using the type argument:\n\n\"folder\" ‚Äì show only subdirectories\n\n\"file\" ‚Äì show only files\n\n\"both\" ‚Äì show everything (the default)\n\nThe return value is a character vector of full paths. The results are sorted so that folders appear before files, and items are sorted alphabetically within each group. This makes it easier to scan through large data directories and find the datasets you need.\nThis function is especially useful when: - you want to confirm the correct file path before calling import_from_rgsd()\n- you need to explore an unfamiliar part of the GeoSpatialData directory\n- you want to quickly check what versions, ‚ÄúOriginal/Processed‚Äù subfolders, or file formats are available\n- you are scripting data access and need reproducible directory navigation"
  },
  {
    "objectID": "articles/functions_geospatialdata.html#import_from_rgsd",
    "href": "articles/functions_geospatialdata.html#import_from_rgsd",
    "title": "Functions for data on R:",
    "section": "import_from_rgsd()",
    "text": "import_from_rgsd()\nimport_from_rgsd() is a convenience function for loading spatial datasets directly from the GeoSpatialData directory. Instead of remembering which R package or function to use for each file type, this function automatically chooses the correct tool based on the file extension.\nYou can provide either: - a relative path from /data/R/GeoSpatialData, or\n- a full absolute path to a file or directory.\nThe function then determines the file type and loads it using the appropriate approach:\n\nVector formats\nHandled via sf: - Shapefiles (.shp) - GeoJSON files (.geojson) - GeoPackage files (.gpkg) ‚Äì requires specifying a layer name\n- File Geodatabases (.gdb) ‚Äì requires specifying a layer name\n- GeoParquet files (.parquet) (using sfarrow)\n\n\nRaster formats\nHandled via terra: - GeoTIFF (.tif, .tiff) - IMG, ASC, VRT - NetCDF (.nc) - Other raster formats supported by terra\nFor multi-layer file types (GPKG, GDB), you must supply a layer argument so the function knows which dataset inside the container to load. If you are unsure which layers are available, you can inspect them with:\nsf::st_layers(path_to_file)\nimport_from_rgsd() returns:\n\nan sf object when reading vector data\n\na SpatRaster when reading raster data\n\nThis function is helpful when:\n\nworking with multiple formats across a project\n\nstandardizing data access in shared scripts or pipelines\n\navoiding mistakes caused by mixing terra and sf usage\n\nloading datasets from deeply nested directories\n\nwriting reproducible code that does not depend on the working directory\n\nTogether, list_from_rgsd() and import_from_rgsd() streamline access to NINA‚Äôs shared spatial datasets and reduce the friction of navigating a large, diverse data archive."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to GeoLink",
    "section": "",
    "text": "GeoLink is a new initiative at NINA designed to make it easier for researchers and engineers to access, understand, and use the organisation‚Äôs geospatial data. Over decades, NINA has accumulated extensive datasets on species, climate, land use, ecosystems, and human activity‚Äîresources that are central to our research and activities. However, much of this data is scattered across different repositories, poorly catalogued, and often difficult for non-experts to import into their workflows. As a result, NINA employees spend too much time searching for, re-downloading, or re-processing data that already exists. GeoLink aims to reduce these barriers by creating a shared overview of environmental geospatial datasets and developing practical tools that make the data easy to find and use.\nThe project focuses on two main areas: improving data visibility and building user-friendly tools. First, GeoLink will compile an updated, researcher-driven inventory of the most relevant geospatial datasets hosted at NINA. This will be prioritized for national-scale environmental data frequently used in ecological modelling and land-use planning. In parallel, will be the development of functions that allow users to import ‚Äúanalysis-ready‚Äù geospatial data directly into their workflow without needing advanced technical skills. This includes exploring storage solutions, ensuring interoperability, and laying the groundwork for long-term alignment with Milj√∏data.\nBy improving access to shared data, GeoLink supports more efficient research, reduces duplicated effort, and strengthens collaboration across departments. Easier access to geospatial resources will help new staff get up to speed faster, lower the technical threshold for working with spatial data, and reduce pressure on NINA‚Äôs IT infrastructure. Ultimately, the project will provide a strategy for accessing and working with geospatial data as our organization continues to grow.\nUse the navigation bar on the top to view the various data sources and explore functions and how-to vignettes."
  }
]